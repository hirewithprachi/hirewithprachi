import { supabase } from '../lib/supabase';

export class DownloadService {
  constructor() {
    this.bucketName = 'resource-downloads';
    this.baseUrl = import.meta.env.VITE_SUPABASE_URL;
  }

  // Create lead and initiate download process
  async initiateDownload(resourceId, leadData, metadata = {}) {
    try {
      // First, create the lead
      const leadResult = await this.createLeadForDownload(leadData, resourceId);
      if (!leadResult.success) throw new Error(leadResult.error);

      // Track the download and generate secure token
      const downloadResult = await this.trackDownload(
        resourceId,
        leadResult.lead.id,
        leadData.email,
        leadData,
        metadata
      );

      return {
        success: true,
        downloadUrl: downloadResult.downloadUrl,
        token: downloadResult.token,
        lead: leadResult.lead,
        expiresAt: downloadResult.expiresAt,
      };
    } catch (error) {
      console.error('Download initiation failed:', error);
      return { success: false, error: error.message };
    }
  }

  // Create a new resource using AI-generated content and save to Storage
  async generateResource({ title, categoryId, prompt }) {
    try {
      if (!title || !categoryId || !prompt) {
        throw new Error('Missing required fields: title, categoryId, prompt');
      }

      // 1) Generate content via Supabase Edge Function (preferred), with safe fallbacks
      let content = '';
      try {
        // Try your Edge Function first (choose the name you deployed)
        // It should respond with { content: "...markdown..." } or { markdown: "...", ... }
        const tryNames = ['generate-ai-resource', 'generate-resource'];
        let edgeError = null;

        for (const name of tryNames) {
          const { data, error } = await supabase.functions.invoke(name, {
            body: { title, prompt },
          });
          if (!error && data) {
            content =
              (data.content && String(data.content).trim()) ||
              (data.markdown && String(data.markdown).trim()) ||
              (data.text && String(data.text).trim()) ||
              '';
            if (content) break;
          } else {
            edgeError = error;
          }
        }

        if (!content && edgeError) throw edgeError;
      } catch (edgeErr) {
        // Fallback to direct OpenAI (only if you *also* set VITE_OPENAI_API_KEY in the frontend)
        const openAIKey = import.meta.env.VITE_OPENAI_API_KEY;
        if (!openAIKey) {
          // Last-resort minimal content to avoid hard failure
          content = `# ${title}\n\n${prompt}\n\n*This resource will be updated after AI generation is configured.*`;
        } else {
          const aiResponse = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${openAIKey}`,
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              model: 'gpt-4o-mini',
              messages: [
                {
                  role: 'system',
                  content:
                    'You are an HR expert. Generate a high-quality HR resource (guide/template/checklist). Provide clear sections, headings, and practical content formatted in Markdown.',
                },
                {
                  role: 'user',
                  content: `Title: ${title}\n\nPrompt: ${prompt}\n\nPlease generate a professional, ready-to-download HR resource in Markdown. Include an intro, detailed sections, bullet points, and a conclusion.`,
                },
              ],
              max_tokens: 2000,
              temperature: 0.7,
            }),
          });

          if (!aiResponse.ok) throw new Error(`OpenAI API error: ${aiResponse.status}`);
          const aiJson = await aiResponse.json();
          content = aiJson?.choices?.[0]?.message?.content?.trim() || '';
        }
      }

      if (!content) throw new Error('No content generated by AI');

      // 2) Convert to DOCX client-side and upload
      const slug = this.slugify(title);
      const docxPath = `generated/${Date.now()}-${slug}.docx`;

      // dynamic import to avoid test-time bundling issues
      const docx = await import('docx');
      const { Document, Packer, Paragraph } = docx;
      const paragraphs = content.split('\n\n').map((block) => new Paragraph(block));
      const doc = new Document({ sections: [{ properties: {}, children: paragraphs }] });
      const docBlob = await Packer.toBlob(doc);

      const { error: uploadDocxError } = await supabase.storage
        .from(this.bucketName)
        .upload(docxPath, docBlob, {
          upsert: false,
          contentType:
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        });
      if (uploadDocxError) throw uploadDocxError;

      // Generate PDF alongside DOCX via render-pdf function
      let pdfPath = docxPath.replace(/\.docx$/, '.pdf');
      try {
        // Prefer invoking through supabase-js (adds auth automatically)
        const { error: pdfFnError } = await supabase.functions.invoke('render-pdf', {
          body: { markdown: content, title, outputPath: pdfPath },
        });
        if (pdfFnError) {
          // fallback to direct fetch if your function requires it
          const resp = await fetch(`${this.baseUrl}/functions/v1/render-pdf`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ markdown: content, title, outputPath: pdfPath }),
          });
          if (!resp.ok) pdfPath = null;
        }
      } catch {
        pdfPath = null;
      }

      // 3) Save resource row
      const { data: resource, error: insertError } = await supabase
        .from('resources')
        .insert([
          {
            title,
            category_id: categoryId,
            type: 'guide',
            content,
            file_path: pdfPath || docxPath,
            file_size_bytes: docBlob.size,
            mime_type: pdfPath
              ? 'application/pdf'
              : 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
            requires_lead_capture: true,
            created_at: new Date().toISOString(),
          },
        ])
        .select()
        .single();
      if (insertError) throw insertError;

      return { success: true, data: resource };
    } catch (error) {
      console.error('AI resource generation failed:', error);
      return { success: false, error: error.message };
    }
  }

  // Category CRUD for admin panel
  async createCategory({ name, description, icon, color }) {
    try {
      const { data, error } = await supabase
        .from('resource_categories')
        .insert([{ name, description, icon: icon || 'FileText', color: color || 'blue' }])
        .select()
        .single();
      if (error) throw error;
      return { success: true, data };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  async updateCategory(id, { name, description, icon, color }) {
    try {
      const { data, error } = await supabase
        .from('resource_categories')
        .update({ name, description, icon, color, updated_at: new Date().toISOString() })
        .eq('id', id)
        .select()
        .single();
      if (error) throw error;
      return { success: true, data };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  async deleteCategory(id) {
    try {
      const { error } = await supabase.from('resource_categories').delete().eq('id', id);
      if (error) throw error;
      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  // Helpers
  slugify(text) {
    return (text || '')
      .toString()
      .toLowerCase()
      .trim()
      .replace(/[^a-z0-9 -]/g, '')
      .replace(/\s+/g, '-')
      .replace(/-+/g, '-');
  }

  // Create lead specifically for download
  async createLeadForDownload(leadData, resourceId) {
    try {
      // Get resource info for lead source detail
      const { data: resource } = await supabase
        .from('resources')
        .select('title, category_id, resource_categories(name)')
        .eq('id', resourceId)
        .single();

      const leadPayload = {
        name: `${leadData.firstName} ${leadData.lastName}`.trim(),
        first_name: leadData.firstName || '',
        last_name: leadData.lastName || '',
        email: leadData.email,
        phone: leadData.phone || null,
        company_name: leadData.company || null,
        job_title: leadData.position || null,
        industry: leadData.industry || null,
        company_size: leadData.companySize || null,
        notes:
          leadData.message || `Requested download: ${resource?.title || 'Resource'}`,
        source: 'resource_download',
        status: 'new',
        lead_score: 70, // Downloads indicate high interest
        created_at: new Date().toISOString(),
      };

      // First, try to insert the lead
      const { data: lead, error } = await supabase
        .from('leads')
        .insert([leadPayload])
        .select()
        .single();

      if (error) {
        // If it's a unique constraint violation, try to get existing lead
        if (error.code === '23505') {
          console.log('Lead with this email already exists, fetching existing lead...');

          const { data: existingLead, error: fetchError } = await supabase
            .from('leads')
            .select('*')
            .eq('email', leadData.email)
            .single();

          if (fetchError) {
            console.error('Failed to fetch existing lead:', fetchError);
            throw fetchError;
          }

          if (existingLead) {
            // Update existing lead with download info
            const updatePayload = {
              notes:
                (existingLead.notes || '') +
                `\nDownloaded: ${resource?.title || 'Resource'} on ${new Date().toLocaleDateString()}`,
              updated_at: new Date().toISOString(),
            };

            const { data: updatedLead, error: updateError } = await supabase
              .from('leads')
              .update(updatePayload)
              .eq('id', existingLead.id)
              .select()
              .single();

            if (updateError) {
              console.error('Failed to update existing lead:', updateError);
              throw updateError;
            }

            return { success: true, lead: updatedLead };
          }
        }

        // For other errors, throw them
        throw error;
      }

      return { success: true, lead };
    } catch (error) {
      console.error('Lead creation failed:', error);
      return { success: false, error: error.message };
    }
  }

  // Track download and generate secure token
  async trackDownload(resourceId, leadId, userEmail, leadData, metadata) {
    try {
      const { data, error } = await supabase.rpc('track_resource_download', {
        p_resource_id: resourceId,
        p_lead_id: leadId,
        p_user_email: userEmail,
        p_user_name: `${leadData.firstName} ${leadData.lastName}`.trim(),
        p_company_name: leadData.company || null,
        p_phone: leadData.phone || null,
        p_ip_address: metadata.ipAddress || null,
        p_user_agent: metadata.userAgent || navigator.userAgent,
        p_referrer: metadata.referrer || document.referrer,
        p_utm_source: metadata.utmSource || null,
        p_utm_medium: metadata.utmMedium || null,
        p_utm_campaign: metadata.utmCampaign || null,
      });

      if (error) {
        console.error('Track download RPC error:', error);
        // Fallback: create download record manually
        return await this.createDownloadRecordManually(
          resourceId,
          leadId,
          userEmail,
          leadData,
          metadata
        );
      }

      // Get the generated token from the download record
      const { data: downloadRecord, error: downloadError } = await supabase
        .from('resource_downloads')
        .select('download_url, expires_at')
        .eq('id', data)
        .single();

      if (downloadError) {
        console.error('Download record fetch error:', downloadError);
        throw downloadError;
      }

      // Extract token from download URL
      const token = downloadRecord.download_url.split('/').pop();

      return {
        downloadUrl: `${this.baseUrl}/functions/v1/download-resource/${token}?email=${encodeURIComponent(
          userEmail
        )}`,
        token,
        expiresAt: downloadRecord.expires_at,
      };
    } catch (error) {
      console.error('Download tracking failed:', error);
      // Fallback: try direct file download
      return await this.getDirectDownloadUrl(resourceId);
    }
  }

  // Fallback method to create download record manually
  async createDownloadRecordManually(resourceId, leadId, userEmail, leadData, metadata) {
    try {
      const token = this.generateSecureToken();
      const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours

      const { data: downloadRecord, error } = await supabase
        .from('resource_downloads')
        .insert([
          {
            resource_id: resourceId,
            lead_id: leadId,
            user_email: userEmail,
            user_name: `${leadData.firstName} ${leadData.lastName}`.trim(),
            company_name: leadData.company || null,
            phone: leadData.phone || null,
            ip_address: metadata.ipAddress || null,
            user_agent: metadata.userAgent || navigator.userAgent,
            referrer: metadata.referrer || document.referrer,
            utm_source: metadata.utmSource || null,
            utm_medium: metadata.utmMedium || null,
            utm_campaign: metadata.utmCampaign || null,
            download_url: token,
            expires_at: expiresAt,
          },
        ])
        .select('download_url, expires_at')
        .single();

      if (error) throw error;

      return {
        downloadUrl: `${this.baseUrl}/functions/v1/download-resource/${token}?email=${encodeURIComponent(
          userEmail
        )}`,
        token,
        expiresAt: downloadRecord.expires_at,
      };
    } catch (error) {
      console.error('Manual download record creation failed:', error);
      throw error;
    }
  }

  // Fallback method to get direct download URL
  async getDirectDownloadUrl(resourceId) {
    try {
      // Get resource file path
      const { data: resource, error } = await supabase
        .from('resources')
        .select('file_path, title')
        .eq('id', resourceId)
        .single();

      if (error) throw error;

      if (resource.file_path) {
        // Get public URL from storage
        const { data: urlData } = supabase.storage
          .from(this.bucketName)
          .getPublicUrl(resource.file_path);

        return {
          downloadUrl: urlData.publicUrl,
          token: null,
          expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000),
        };
      } else {
        throw new Error('Resource file not found');
      }
    } catch (error) {
      console.error('Direct download URL generation failed:', error);
      throw error;
    }
  }

  // Generate secure token
  generateSecureToken() {
    const array = new Uint8Array(32);
    crypto.getRandomValues(array);
    return Array.from(array, (byte) => byte.toString(16).padStart(2, '0')).join('');
  }

  // Get all resources with categories
  async getResources(options = {}) {
    try {
      let query = supabase
        .from('resources')
        .select(
          `
          *,
          resource_categories (
            id,
            name,
            description,
            icon,
            color
          )
        `
        )
        .order('is_featured', { ascending: false })
        .order('created_at', { ascending: false });

      if (options.categoryId) query = query.eq('category_id', options.categoryId);
      if (options.featured) query = query.eq('is_featured', true);
      if (options.type) query = query.eq('type', options.type);
      if (options.limit) query = query.limit(options.limit);

      const { data, error } = await query;
      if (error) throw error;

      return { success: true, data: data || [] };
    } catch (error) {
      console.error('Failed to fetch resources:', error);
      return { success: false, error: error.message, data: [] };
    }
  }

  // Get resource categories
  async getCategories() {
    try {
      const { data, error } = await supabase
        .from('resource_categories')
        .select('*')
        .eq('is_active', true)
        .order('sort_order');

      if (error) throw error;

      return { success: true, data: data || [] };
    } catch (error) {
      console.error('Failed to fetch categories:', error);
      return { success: false, error: error.message, data: [] };
    }
  }

  // Get download statistics for admin
  async getDownloadStats(options = {}) {
    try {
      const { data, error } = await supabase
        .from('resource_downloads')
        .select(
          `
          *,
          resources (
            title,
            category_id,
            resource_categories (name)
          ),
          leads (
            name,
            email,
            company,
            status
          )
        `
        )
        .order('created_at', { ascending: false });

      if (error) throw error;

      // Calculate statistics
      const totalDownloads = data.length;
      const completedDownloads = data.filter((d) => d.download_completed).length;
      const uniqueUsers = new Set(data.map((d) => d.user_email)).size;
      const conversionRate =
        totalDownloads > 0 ? ((completedDownloads / totalDownloads) * 100).toFixed(1) : '0.0';

      // Group by resource
      const resourceStats = data.reduce((acc, download) => {
        const resourceId = download.resource_id;
        if (!acc[resourceId]) {
          acc[resourceId] = {
            resource: download.resources,
            downloads: 0,
            completed: 0,
            uniqueUsers: new Set(),
          };
        }
        acc[resourceId].downloads++;
        if (download.download_completed) acc[resourceId].completed++;
        acc[resourceId].uniqueUsers.add(download.user_email);
        return acc;
      }, {});

      // Convert to array and add unique user counts
      const resourceStatsArray = Object.values(resourceStats).map((stat) => ({
        ...stat,
        uniqueUsers: stat.uniqueUsers.size,
      }));

      return {
        success: true,
        stats: {
          totalDownloads,
          completedDownloads,
          uniqueUsers,
          conversionRate: `${conversionRate}%`,
        },
        resourceStats: resourceStatsArray,
        downloads: data,
      };
    } catch (error) {
      console.error('Failed to fetch download stats:', error);
      return { success: false, error: error.message };
    }
  }

  // Admin: Create new resource
  async createResource(resourceData) {
    try {
      const { data, error } = await supabase
        .from('resources')
        .insert([
          {
            ...resourceData,
            created_at: new Date().toISOString(),
            download_count: 0,
          },
        ])
        .select()
        .single();

      if (error) throw error;

      return { success: true, data };
    } catch (error) {
      console.error('Failed to create resource:', error);
      return { success: false, error: error.message };
    }
  }

  // Admin: Update resource
  async updateResource(resourceId, updates) {
    try {
      const { data, error } = await supabase
        .from('resources')
        .update({
          ...updates,
          updated_at: new Date().toISOString(),
        })
        .eq('id', resourceId)
        .select()
        .single();

      if (error) throw error;

      return { success: true, data };
    } catch (error) {
      console.error('Failed to update resource:', error);
      return { success: false, error: error.message };
    }
  }

  // Admin: Delete resource
  async deleteResource(resourceId) {
    try {
      const { error } = await supabase.from('resources').delete().eq('id', resourceId);
      if (error) throw error;
      return { success: true };
    } catch (error) {
      console.error('Failed to delete resource:', error);
      return { success: false, error: error.message };
    }
  }

  // Upload file to Supabase Storage
  async uploadFile(file, fileName, folder = 'resources') {
    try {
      const filePath = `${folder}/${Date.now()}-${fileName}`;

      const { data, error } = await supabase.storage
        .from(this.bucketName)
        .upload(filePath, file, {
          cacheControl: '3600',
          upsert: false,
        });

      if (error) throw error;

      // Get public URL
      const { data: urlData } = supabase.storage
        .from(this.bucketName)
        .getPublicUrl(filePath);

      return {
        success: true,
        filePath,
        publicUrl: urlData.publicUrl,
        size: file.size,
      };
    } catch (error) {
      console.error('File upload failed:', error);
      return { success: false, error: error.message };
    }
  }

  // Generate AI summary for resource (via Edge Function; tries two names, then safe fallback)
  async generateAISummary(resourceTitle, resourceDescription) {
    try {
      const payload = {
        title: resourceTitle,
        description: resourceDescription,
        resourceTitle,
        resourceDescription,
      };

      // Prefer Edge Function(s)
      const names = ['generate-ai-summary', 'generate-summary'];
      for (const name of names) {
        try {
          const { data, error } = await supabase.functions.invoke(name, { body: payload });
          if (!error && data) {
            const summary = (data.summary && String(data.summary).trim()) || '';
            if (summary) {
              return { success: true, summary };
            }
          }
        } catch {
          /* try next */
        }
      }

      // Fallback if function(s) not found or returned empty
      const fallback = String(resourceDescription || '').trim();
      return {
        success: true,
        summary:
          fallback.length > 160
            ? `${fallback.substring(0, 157)}...`
            : fallback || 'A concise HR resource to help you get started.',
      };
    } catch (error) {
      console.error('AI summary generation failed:', error);
      const fallback = String(resourceDescription || '').trim();
      return {
        success: false,
        error: error.message,
        summary:
          fallback.length > 160
            ? `${fallback.substring(0, 157)}...`
            : fallback || 'A concise HR resource to help you get started.',
      };
    }
  }

  // Format file size for display
  formatFileSize(bytes) {
    if (!bytes && bytes !== 0) return 'Unknown size';
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    if (bytes === 0) return '0 Bytes';
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    return Math.round((bytes / Math.pow(1024, i)) * 100) / 100 + ' ' + sizes[i];
  }

  // Get UTM parameters from URL
  getUTMParameters() {
    const urlParams = new URLSearchParams(window.location.search);
    return {
      utmSource: urlParams.get('utm_source'),
      utmMedium: urlParams.get('utm_medium'),
      utmCampaign: urlParams.get('utm_campaign'),
    };
  }

  // Get user metadata
  getUserMetadata() {
    return {
      userAgent: navigator.userAgent,
      referrer: document.referrer,
      ...this.getUTMParameters(),
    };
  }
}

// Export singleton instance
export const downloadService = new DownloadService();
export default downloadService;

// Optional named export for compatibility with prior imports.
// This simply proxies to the singleton's method.
export async function generateAISummary(resourceTitle, resourceDescription) {
  return downloadService.generateAISummary(resourceTitle, resourceDescription);
}
